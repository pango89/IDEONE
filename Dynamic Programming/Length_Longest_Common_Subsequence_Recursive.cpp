/*
LCS PROBLEM STATEMENT: GIVEN TWO SEQUENCES, FIND THE LENGTH OF LONGEST SUBSEQUENCE PRESENT IN BOTH OF THEM. 
A SUBSEQUENCE IS A SEQUENCE THAT APPEARS IN THE SAME RELATIVE ORDER, BUT NOT NECESSARILY CONTIGUOUS. 
FOR EXAMPLE, “ABC”, “ABG”, “BDF”, “AEG”, ‘”ACEFG”, .. ETC ARE SUBSEQUENCES OF “ABCDEFG”. 
SO A STRING OF LENGTH N HAS 2^N DIFFERENT POSSIBLE SUBSEQUENCES.
IT IS A CLASSIC COMPUTER SCIENCE PROBLEM, THE BASIS OF DIFF (A FILE COMPARISON PROGRAM THAT OUTPUTS 
THE DIFFERENCES BETWEEN TWO FILES), AND HAS APPLICATIONS IN BIOINFORMATICS.

EXAMPLES:
LCS FOR INPUT SEQUENCES “ABCDGH” AND “AEDFHR” IS “ADH” OF LENGTH 3.
LCS FOR INPUT SEQUENCES “AGGTAB” AND “GXTXAYB” IS “GTAB” OF LENGTH 4.
THE NAIVE SOLUTION FOR THIS PROBLEM IS TO GENERATE ALL SUBSEQUENCES OF BOTH GIVEN SEQUENCES AND 
FIND THE LONGEST MATCHING SUBSEQUENCE. THIS SOLUTION IS EXPONENTIAL IN TERM OF TIME COMPLEXITY. 
FOLLOWING IS SIMPLE RECURSIVE IMPLEMENTATION OF THE LCS PROBLEM. 
THE IMPLEMENTATION SIMPLY FOLLOWS THE RECURSIVE STRUCTURE MENTIONED ABOVE.

TIME COMPLEXITY OF THE ABOVE NAIVE RECURSIVE APPROACH IS O(2^N) IN WORST CASE 
AND WORST CASE HAPPENS WHEN ALL CHARACTERS OF X AND Y MISMATCH I.E., LENGTH OF LCS IS 0.
*/
#include<stdio.h>
#include<stdlib.h>
 
/* UTILITY FUNCTION TO GET MAX OF 2 INTEGERS */
int max(int a, int b)
{
    return (a > b)? a : b;
}
 
/* RETURNS LENGTH OF LCS FOR X[0..M-1], Y[0..N-1] */
int lcs( char *X, char *Y, int m, int n )
{
   if (m == 0 || n == 0)
     return 0;
   if (X[m-1] == Y[n-1])
     return 1 + lcs(X, Y, m-1, n-1);
   else
     return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));
}
 
/* DRIVER PROGRAM TO TEST ABOVE FUNCTION */
int main()
{
  char X[] = "AGGTAB";
  char Y[] = "GXTXAYB";
 
  int m = strlen(X);
  int n = strlen(Y);
 
  printf("Length of LCS is %d\n", lcs( X, Y, m, n ) );
 
  getchar();
  return 0;
}
/*
CONSIDERING THE ABOVE IMPLEMENTATION, FOLLOWING IS A PARTIAL RECURSION TREE FOR INPUT STRINGS “AXYT” AND “AYZX”

                         LCS("AXYT", "AYZX")
                       /                 \
         LCS("AXY", "AYZX")            LCS("AXYT", "AYZ")
         /            \                  /               \
LCS("AX", "AYZX") LCS("AXY", "AYZ")   LCS("AXY", "AYZ") LCS("AXYT", "AY")
IN THE ABOVE PARTIAL RECURSION TREE, LCS(“AXY”, “AYZ”) IS BEING SOLVED TWICE. 
IF WE DRAW THE COMPLETE RECURSION TREE, THEN WE CAN SEE THAT THERE ARE MANY 
SUBPROBLEMS WHICH ARE SOLVED AGAIN AND AGAIN. SO THIS PROBLEM HAS OVERLAPPING 
SUBSTRUCTURE PROPERTY AND RECOMPUTATION OF SAME SUBPROBLEMS CAN BE AVOIDED 
BY EITHER USING MEMOIZATION OR TABULATION.
*/